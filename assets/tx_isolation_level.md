# 트랜잭션

---

-all or nothing

트랜잭션은 작업의 완전성을 보장해주는 성질임. 즉, 여러 논리적인 작업이 있을 때, 이를 하나의 집합으로 묶어서 처리하는 개념이다. 모두 완벽하게 처리하거나, 하나라도 실패하면 모두 작업 처리 전 상태로 되돌 릴 수 있어야 함. 사용자 입장에서는 작업의 논리적인 단위로 이해할 수 있고, 시스템 입장에서는 데이터들을 접근하고 변경하는 단위로 다룰 수 있다.

## vs Lock

lock은 동시성 보장을 위한 것이고, 트랜잭션은 정합성을 보장하기 위한 거이다. 즉 여러 커넥션에서 동일한 자원(테이블, 레코드)에 대해 접근했을 때, 한 시점에는 하나에 커넥션만 허용하는 게 lock이다. 이와는 다르게 트랜잭션은 여러 변경 작업을 수행하는 쿼리에만 해당되는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 집합에 대해 실질 쿼리가 몇개든 상관없이 이 작업 전체가 모두 되던가 아예 안되던가

## ACID

트랜잭션이 가져야 할 4가지 속성. 원자성, 일관성, 격리성, 지속성이 있음.

- Atomicity, 원자성: 트랜잭션 중에 아무런 문제도 발생하지 않은 경우에만 모든 작업들이 처리되어야 한다. 어떤 트랜잭션 중간에 문제가 발생하면 해당 트랜잭션 내의 어떤 작업도 수행되서는 안된다. 이미 수행됐다면 수행 전으로 되돌려야 한다.
- Consistency, 일관성: 트랜잭션이 완료된 상태 이후에도, 트랜잭션이 처리되기 전과 같게 데이터의 일관성을 보장해야 한다. 예를 들어, 스키마/제약조건/비즈니스 규칙 등이 바뀌어선 안된다.
- Isolation, 격리성: 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. 동시에 실행되더라도 마치 순차적으로 실행된 것과 같아야 한다. (락, 트랜잭션 격리수준을 통해 구현한다.)
- Durability, 지속성: 커밋이 안료되면 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. 꺼짐/장애 등이 발생하더라도 이를 보장해야 한다.

 

## MVCC

데이터를 한 개만 유지하지 않고 여러 버전을 동시에 유지하는 동시성 제어 방식

락 기반방식:

- 어떤 트랜잭션이 row를 읽으면 공유락(S lock)
- 다른 트랜잭션이 그 row를 수정하려면 배타락(X lock) 필요
- 그래서 읽기 많은 시스템에서 쓰기가 막히고, 대기/데드락/지연이 늘어남

MVCC:

- 읽기는 락을 거의 안 잡고, 과거 버전을 읽음
- 쓰기는 새 버전을 만들고 커밋하면 그게 ‘현재’가 됨

(같은 row를 동시에 수정하는 쓰기-쓰기 충돌은 막아야 해서 락/충돌검사는 아직 필요

MySQL

- UPDATE/DELETE가 현재 페이지의 레코드를 바꾸는 형태
- 과거 버전은 undo 로그에 이전값으로 저장
- 트랜잭션이 스냅샷(READ VIEW)을 잡으면(읽을 때 필요하면) 언두 따라가며 옛 버전을 복원해서 읽음
- MVCC의 과거 버전은 undo 기반으로 재구성

Postgres

- UPDATE는 덮어쓰기가 아니라 새 튜플을 추가로 생성 (기존 튜플은 남겨둠)
- 각 튜플에 xmin/xmax 같은 누가 만들고/지웠는지 메타정보가 있고,
- 읽을 때는 스냅샷 기준으로 가시성(visibility)을 판단해서 보이는 튜플 버전만 선택함
- 즉, MVCC의 과거 버전이 테이블(힙)에 그대로 존재하고, Undo로 복원하지 않음
- 이 때문에 VACUUM이 죽은 튜플 정리의 핵심 운영 포인트가 됨

## rollback

트랜잭션 수행 중 변경사항을 취소하고 변경 전으로 되돌리는 것. 원자성을 지키기 위한 작업. 

mysql의 경우, undo 로그를 기반으로 되감는다. postgre의 경우 버전 정보를 이용한다.

### undo와 redo in MySQL, PostgreSQL

MySQL

- undo: 롤백, MVCC에 사용
- redo: 커밋된 데이터를 나중에 적용할 때 씀 데이터 정합성 틀어지면 재적용으로 복구시킴

PostgreSQL

- 전통적인 의미에 undo가 없음…
- MVCC를 row새로 쓴 버전을 둠

### MySQL에서의 rollback

1. 쓰기 tx발생(update/delete/insert), 락 획득
2. undo로그에 tx전 정보 기록
3. 버퍼풀의 페이지를 실제로 수정
4. redo에 변경사항을 기록

rollback이 호출되면

- 이 트래잭션이 만든 undo레코드를 최신 것부터 역순으로 적용(stack)
- 롤백도 페이지를 수정하는것이므로 redo에 기록함

주의사항

- SAVEPOINT는 undo 로그의 특정 시점을 찍어두고 그 이후만 부분 롤백.
- 대량 변경 후 롤백은 undo 적용 자체가 오래 걸릴 수 있고, 그동안 락 때문에 다른 트랜잭션이 막힐 수 있다.

### PostgreSQL에서의 rollback

postgreSQL에서의 MVCC는 기존 row를 덮어쓰지 않음

- update: 새로운 버전의 튜플을 만들고 이전 버전을 남김.
- delete: tuple를 물리적으로 삭제하지 않고, 삭제됐다고 표시해둔다.

*tuple: 한 record의 한 버전* 

tuple에 붙는 메타: xmin, xmax

- xmin: 튜플을 만든 tx-id
- xmax: 튜플을 죽인(갱신/삭제) tx-id

tx1 rollback 호출 시(abort)

- 트랜잭션 상태 테이블(commit/abort 여부 기록)에 tx1을 abort로 기록
- tx1이 만든 새 튜플은 커밋되지 않은 버전이므로 다른 트랜잭션에서 보이지 않음
- 별도의 undo를 길게하지 않고도 논리적으로 변경이 사라짐

물리적으로는..

- abort된 트랜잭션이 만든 튜플/업데이트로 인한 쓰레기 튜플은 디스크에 남을 수 있음
- 이건 vaccum이 회수해서 공간을 재사용 가능하게 만든다.

주의사항

- 롤백이 빠르다?
    
    undo를 적용하며 되감는 작업이 적다. but, 롤백 시점까지 잡고 있던 락은 트랜잭션 종료까지 유지되는 경우가 많아서, 동시성 측면에서 체감 영향은 여전히 클 수 있다.
    

### mysql과 postgre의 rollback시간 차이가 유의미한 경우

한 트랜잭션에서 수십만~수천만 row를 UPDATE/DELETE/INSERT 하다가 에러로 `ROLLBACK`

- InnoDB
    - 그 수많은 변경을 undo 로그로 하나씩 되감는 작업을 실제로 수행함
    - rollback 명령 자체가 분~시간 단위로 길어질 수 있고, I/O도 튐
    - 롤백이 진행되는 동안 관련 row/범위 락이 부분적으로 계속 유지되어 다른 트랜잭션이 막힐 수 있음
- PostgreSQL
    - 보통 abort 는 “이 트랜잭션은 실패”로 표시하고 끝 → 응답은 빠른 편
    - 다만 디스크에는 업데이트로 만든 새 버전 튜플이 남고(= dead tuple)
        
        이후 VACUUM이 청소하기 전까지 테이블/인덱스가 불어나 성능이 떨어질 수 있음
        

지금 당장 ROLLBACK 응답 시간”이 중요하면 PostgreSQL이 유리한 케이스가 많음

## Transaction 격리 수준

여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것

### 이상현상

1. Dirty Read (더티 리드)
    - 다른 트랜잭션이 아직 커밋하지 않은 값을 읽는 것
    - 상대가 롤백하면 존재하지 않았던 값을 읽은 것.
2. Non-Repeatable Read 
    - 같은 트랜잭션에서 같은 행을 두 번 읽었는데 값이 달라지는 것
    - 중간에 다른 트랜잭션이 커밋한 업데이트가 반영됨
3. Phantom Read
    - 같은 트랜잭션에서 같은 조건으로 여러 행을 조회했는데, 두 번째 조회에서 행의 개수/구성이 바뀌는 것
    - 중간에 다른 트랜잭션이 조건에 맞는 행을 INSERT/DELETE해서 발생

### Serializable

트랜잭션을 순차적으로 진행시킴.

- 어떤 부정합 문제도 발생하지 않음. 다만 모든 트랜잭션이 순차적으로 처리되어 동시처리 성능이 매우 떨어짐

**MySQL(InnoDB) SERIALIZABLE**

비관락 느낌

- InnoDB는 SERIALIZABLE에서 순수 SELECT를 공유락 읽기로 수행
- 읽기도 락을 잡으니까, 동시성이 크게 떨어지고 대기가 늘 수 있음.
- 범위 조회: locking read가 인덱스 범위를 잠금 → phantom을 락으로 막음
- 블로킹/데드락/락 대기가 늘어남

**PostgreSQL SERIALIZABLE**

SSI(Serializable Snapshot Isolation) 방식

낙관락 느낌

- 스냅샷으로 읽으면서, 동시 트랜잭션 간 read/write 의존성을 감시해서 직렬 실행으로 불가능한 패턴이면 한 쪽을 롤백시킴
    - 락으로 다 막기보단 실패 + 재시도
    - 애플리케이션 레벨에서 같은 트랜잭션 블록 재시도가 필수적임

### Reapetable Read

- Dirty read 방지
- Non-repeatable read 방지(같은 행을 두 번 읽으면 값이 바뀌지 않게)

동작 원리

- 읽은 행에 대해 공유락(읽기락) 걸고 트랜잭션을 유지
    
    → 다른 트랜잭션의 쓰기락(배타락)이 막혀서 같은 행의 값은 반복해서 동일하게 보임.
    
- 하지만 범위 조건에서 범위 전체를 잠그는 범위락은 보장하지 않아서, 다른 트랜잭션이 그 조건에 들어오는 새 행을 INSERT하면 두 번째 조회에서 행 집합이 바뀌는 phantom이 생길 수 있음.

**MySQL(InnoDB) RR** 

InnoDB는 RR에서 스냅샷(순수 SELECT)과 락을 둘 다 씀.

일반 SELECT(락 없는 순수 SELECT) = Undo 스냅샷

- InnoDB RR에서 SELECT는 락을 안 걸고, 첫 read에서 만든 스냅샷을 트랜잭션 끝까지 유지함.
- 그래서 TX2가 중간에 INSERT를 커밋해도 TX1의 스냅샷엔 안 보이니까, phantom이 안 보임

락 읽기/쓰기 쿼리: 락, next-key/gap락 로 범위 삽입 차단

- RR에서 (select for update, update, delete)는 조건에 따라 락이 달라짐
    - 유니크 인덱스 + 유니크 조건이면 레코드 락만
    - 나머지(범위/비유니크)스캔한 인덱스 범위를 next-key/gap lock으로 잠가서 그 범위에 다른 세션이 INSERT 못 하게 막음
    
    Gap lock: 인덱스 레코드와 레코드 사이의 구간(틈) 을 잠금
    
    - 이 구간에 해당하는 키 범위로 새 레코드 INSERT를 못하게 막음
    
    Next key lock: 레코드 r과 r앞에 범위 gap을 다 락거는거
    
    Next-key lock은 범위에 update도 막힘. gap lock은 update는 안막힘(인덱스 키 제외)
    

주의 사항

공식문서: RR에서 락(UPDATE/INSERT/DELETE/SELECT … FOR …)와 순수 SELECT를 섞지 말라함.

- 순수 SELECT은 과거, locking은 최신 상태라 같은 트랜잭션 안에서 서로 다른 시점을 보게돼서 헷갈림

**PostgreSQL RR**

Snapshot Isolation: 트랜잭션 시작 시점의 스냅샷만 봄

- tx2가 중간에 INSERT/DELETE를 커밋해도, tx1이 같은 조건으로 다시 SELECT하면 행 집합이 바뀌지 않음

업데이트 충돌

- RR에서 `UPDATE/DELETE/SELECT FOR UPDATE` 등 락 작업은 트랜잭션 시작 스냅샷을 기준으로 대상 행을 찾음
- 행이 시작 이후 다른 트랜잭션에 의해 바뀌어 커밋됐다면 대기
- 결국 RR 트랜잭션은 에러나면서 롤백되고 재시도가 필요함

### Read Committed → non reapeatable read, phantom read

한 트랜잭션 내에서 여러번 조회할 경우 다른 트랜잭션의 커밋여부에 따라 다른 결과가 나올 수 있다. 

보장: Dirty read 방지(커밋된 것만 읽음)

허용: Non-repeatable read / Phantom read 가능

직관: 각 쿼리마다 최신 커밋 상태를 본다 → 같은 tx안에서 여러번 조회하면 결과가 바뀔 수 있음

예를 들어, 어떤 트랜잭션에서는 오늘 입금된 총 합을 계산하고 있는데, 다른 트랜잭션에서 계속해서 입금 내역을 커밋하는 상황이라고 하자. 그러면 READ COMMITTED에서는 같은 트랜잭션일지라도 조회할 때마다 입금된 내역이 달라지므로 문제가 생길 수 있다.

**mySQL(InnoDB) RC**

- 읽기(순수 SELECT)
    - 각 SELECT마다 새 스냅샷을 잡고 커밋된 데이터만 본다.
    - 같은 트랜잭션에서도 두 번 SELECT하면 결과가 바뀔 수 있음(Non-repeatable/phantom 등).
- 락 전략
    - RC로 바꾸면 검색/인덱스 스캔에서 gap lock이 꺼짐
        
        즉 범위에 대한 삽입 차단(gap)이 약해져서 동시 INSERT가 잘됨
        
    - 예외: 외래키 체크, 중복키 체크(유니크 충돌) 같은 일부 상황에서는 갭 락이 쓰일 수 있음.

결과적으로..

- RC + `SELECT ... FOR UPDATE`를 해도 읽은 행은 잠그지만, 범위의 틈 삽입까지 막는 건 RR보다 약함.
- 범위 조건 기반 로직은 유니크 제약 + 재시도 패턴이 더 안전하다고 함..

**PostgreSQL RC**

- 읽기(순수 SELECT)
    - 각 쿼리 시작 시점 스냅샷을 본다. 각 쿼리는 시작 전에 커밋된 row만 볼 수 있음.
    - 같은 트랜잭션 안에서도 다음 SELECT은 더 최신 커밋을 볼 수 있음 → Non-repeatable/phantom
- 락 읽기/쓰기
    - `SELECT ... FOR UPDATE/UPDATE/DELETE`는 행 단위로 잠그고 경쟁하면 대기하는 방식
    - 범위 삽입을 막아야 하면 보통 대표행을 잠그거나, 유니크 제약 + 재시도로 풀어야함

### Read Uncommitted → dirty read, non reapeatable read, phantom read

READ UNCOMMITTED는 커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준이다. 

READ UNCOMMITTED에서는 다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보이게 된다.

어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 부정합 문제를 Dirty Read(오손 읽기)라고 한다

→ postgres는 read uncommited도 read committed처럼 동작